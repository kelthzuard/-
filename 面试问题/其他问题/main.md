# 其他问题

## 监测性能的工具

chrome devtool -> performance
https://segmentfault.com/a/1190000011516068?utm_source=sf-similar-article

## require加载的顺序

- 是核心模块加载核心模块
- 有缓存加载缓存
- 如果是目录会尝试加载目录中的index
- 如果是目录和文件会查找指定的目录文件
- 如果不是目录会从父级node_module中寻找，找不到再到父级的父级的node_module中找，直到到顶层文件系统
- 再找不到会到全局变量NODE_PATH中寻找。

## head标签有什么

- title
- script
- link
- meta:描述网页原信息
  - name: 'keyword' content="" 描述网页关键字
  - name: 'description' content="" 描述网页
  - name: 'viewpoint' content="width=device-width, inital-scale=1"
- base:指明所有url的相对url

## 内存泄漏

- 没有使用的全局变量
- 被遗忘的setInterval
- 被遗忘的事件监听器
- 被遗忘的map，set
- 未释放的闭包

监测方法：在devtools  memory一栏take snapshot分析。

## git rebase 和 git merge

- git merge：将分支合并到当前分支上，创建一个merge请求，保留各个分至的所有提交
- git rebase：找到当前分至和合并分至的最近父节点，将合并分至的所有commit插入到父节点头部。

优点：

- 不会产生网状结构，不会有额外merge请求，提交一直保持一条直线

缺点

- 在公共分支上进行rebase会导致提交历史改变，然后所有人在该条历史上工作的人都会产生冲突。

## 进程线程协程

### 进程

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

组成部分：pcb（程序控制块），程序段，数据段

### 线程

线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

组成部分:线程ID，当前指令指针（pc），寄存器集合，堆栈

### 协程

协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

1、进程多与线程比较

线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:

1) 地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间
2) 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源
3) 线程是处理器调度的基本单位,但进程不是
4) 二者均可并发执行
5) 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制

2、协程多与线程进行比较

1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。
2) 线程进程都是同步机制，而协程则是异步
3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态

## 进程和线程通信

进程

- 管道
- 共享内存
- 信号量
- 消息队列
- socket

线程

- 共享内存

## 进程调度

指按一定的策略把处理机分配进程的过程。

进程有几个状态

- 等待态：等待其他资源分配
- 就绪态：其他资源到位，只差处理机
- 占有处理器正在运行

进程调度的时机

- 进程执行完毕
- 进程提出IO请求后被阻塞
- 调用阻塞原语将自己阻塞
- 分时系统中时间片用完
- 就绪队列中进程的优先级高于当前优先级

调度算法

- 时间片轮转：按FIFO给进程分配相同的时间片
- 优先级调度算法：始终把时间片分配给优先级最高的任务
  - 非抢占：当前任务一直用完
  - 抢占式：当前任务不是优先级最高的就会被抢占
- 多级反馈队列：设置多个优先级队列，分配不同的时间片。一个任务在当前队列运行完进入下个队列


## 引入图片的方式

1. img
2. background-img
3. picture
```
<picture>
  <source srcset="/imgBig.png" media="(min-width: 600px)">
  <img src="imgSmall">
</picture>
```
4. svg
```
<svg>
  <image href="">
</svg>
```

## 为什么var可以重复声明，其他不可以

在编译器执行构造活动变量时，遇到已经声明过的var会直接进行赋值。
而遇到let，const会造成临时性死区，报错。

## ios h5 白屏问题

一般是因为safari低版本不支持es6语法，而且babel-loader没有将一些文件进行es6转义，导致直接白屏。  
一般通过排查哪些文件没有进行es6转义，在loader中使用resolve(filename)进行添加就可以了。

## 怎么设置一个对象中的属性不可改变。

通过defineProperty将属性中的

- configurable：仅当设置为true时，该键值才可以被改变，删除
- writeable：仅当设置为true时，才可以赋值

所以把这两个属性设置为false就可以实现无法改变属性了。

## 白屏问题

1. css被放置在底部或者使用@import引入(载入时最后加载)，导致页面最后加载css导致前面出现白屏问题
2. js被放置在头部，导致长时间阻塞页面渲染
3. 代码报错，一般是es6的问题，会导致直接暂停渲染。

## 数据库

数据事物：指连续的一组数据库操作，要么全部成功，要么全部失败

四个特性 acid

- 原子性:atomicity
- 一致性：consistency
- 隔离性：isolation
- 持久性：durability

遇到的问题

- 脏读：读到了其他事物未提交的数据
- 可重复读：在一个事物内，任意时刻读到的数据是一致的
- 不可重复读：在一个事物内，不同时刻读到的同一批数据可能是不一样的
- 幻读：未提交的事物被覆盖

隔离级别

- 读未提交
- 读提交
- 可重复读
- 串行

## 快排时间复杂度和优化

- 最好:当分割点恰好是中位数的时候，每次都是logn，为nlogn
- 最坏：当选取的为最大或最小时，退化为冒泡排序。如果为递增或递减，则退化为n2

优化整体思路就是避免选择的时候选到极端的点，所以

- 随机选择：随机选择基准点，再和left交换即可
- 三路归并：如果每次选择的是中点是最好的，但每次扫描的时间复杂度就会很高。所以选中间和左右三个点的中位数作为基准点。